diff -r cb140bac9ab0 src/cmd/cgo/gcc.go
--- a/src/cmd/cgo/gcc.go	Thu Nov 12 14:55:26 2009 -0800
+++ b/src/cmd/cgo/gcc.go	Sun Nov 15 00:29:05 2009 -0800
@@ -129,9 +129,11 @@
 		if e == nil {
 			break
 		}
+
 		if e.Tag != dwarf.TagVariable {
 			goto Continue
 		}
+
 		name, _ := e.Val(dwarf.AttrName).(string);
 		typOff, _ := e.Val(dwarf.AttrType).(dwarf.Offset);
 		if name == "" || typOff == 0 {
@@ -236,6 +238,7 @@
 type typeConv struct {
 	// Cache of already-translated or in-progress types.
 	m	map[dwarf.Type]*Type;
+	kws	map[string]bool;
 	typedef	map[string]ast.Expr;
 
 	// Predeclared types.
@@ -255,6 +258,7 @@
 func (c *typeConv) Init(ptrSize int64) {
 	c.ptrSize = ptrSize;
 	c.m = make(map[dwarf.Type]*Type);
+	c.kws = make(map[string]bool);
 	c.typedef = make(map[string]ast.Expr);
 	c.byte = c.Ident("byte");
 	c.int8 = c.Ident("int8");
@@ -315,11 +319,15 @@
 	t.Size = dtype.Size();
 	t.Align = -1;
 	t.C = dtype.Common().Name;
+	c.m[dtype] = t;
+
 	if t.Size < 0 {
-		fatal("dwarf.Type %s reports unknown size", dtype)
+		// Treat unsized types as [0]byte
+		t.Size = 0;
+		t.Go = c.Opaque(0);
+		return t;
 	}
 
-	c.m[dtype] = t;
 	switch dt := dtype.(type) {
 	default:
 		fatal("unexpected type: %s", dtype)
@@ -615,6 +623,24 @@
 	csyntax = "struct { ";
 	fld := make([]*ast.Field, 0, 2*len(dt.Field)+1);	// enough for padding around every field
 	off := int64(0);
+
+	// build a map of identifiers to their mangled keywords
+	ident := make(map[string]string);
+	for _, f := range dt.Field {
+		ident[f.Name] = f.Name;
+	}
+	for name, xlate := range ident {
+		if token.Lookup(strings.Bytes(name)).IsKeyword() {
+			xlate = "_" + xlate;
+			ident[name] = xlate;
+
+			for _, exist := ident[xlate]; exist; _, exist = ident[xlate] {
+				ident[xlate] = "_" + ident[xlate];
+				xlate = ident[xlate]
+			}
+		}
+	}
+
 	for _, f := range dt.Field {
 		if f.ByteOffset > off {
 			fld = c.pad(fld, f.ByteOffset-off);
@@ -623,7 +649,10 @@
 		t := c.Type(f.Type);
 		n := len(fld);
 		fld = fld[0 : n+1];
-		fld[n] = &ast.Field{Names: []*ast.Ident{c.Ident(f.Name)}, Type: t.Go};
+
+		fld[n] = &ast.Field{
+			Names: []*ast.Ident{c.Ident(ident[f.Name])},
+			Type: t.Go};
 		off += t.Size;
 		csyntax += t.C + " " + f.Name + "; ";
 		if t.Align > align {
